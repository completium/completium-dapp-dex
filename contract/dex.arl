archetype dex

constant fee           : rational = 0.003
constant epsilon       : nat = 1
constant initialminted : nat = 1000000

variable admin : address = @tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg

asset token {
  id       : string;      /* token label identifier  */
  addr     : address;     /* FA 1.2 contract address */
  poolvalue: nat = 0;     /* XTZ value in pool       */
  totalqty : nat = 0;     /* total number of tokens  */
  totallqt : nat = 0;     /* total LTQ tokens        */
} initialized by {
  {"A"; @KT1MePDQK3VQooqSEwN3sN1WqyMiiGBKGkNX; 0; 0; 0};
  {"B"; @KT1H8JUiFbvEMycCuG5sZfCGHkN7vgfLAs3n; 0; 0; 0}
}

asset liquidity identified by tokenid owner {
  tokenid  : string;      /* token id                */
  owner    : address;     /* LQT owner               */
  lqt      : nat = 0;     /* LQT quantity            */
}

entry registertoken (i : string, a : address) {
  called by admin
  effect { token.add({ id = i; addr = a }); }
}

/* 'caller' sells 'srcqty' of 'src' token
   and acquires 'dstqty' of 'dst' token
   this generates 2 transfers :
  - from caller to token pool of 'srcqty' tokens
  - from token pool to caller of 'dstqty' tokens
  This assumes that caller has emitted an 'allow' transaction prior to this on src token contract.
*/
entry exchange(src : string, srcqty: nat, dst : string, dstqty : nat) {
  require {
    r0 otherwise "SRC_EQ_DST" : src <> dst;
  }
  effect {
    var srctotalqty =
      if src = "XTZ" then
        token[dst].poolvalue
      else
        token[src].totalqty;
    var dsttotalqty =
      if dst = "XTZ" then
        token[src].poolvalue
      else
        token[src].totalqty;
    var K = srctotalqty * dsttotalqty;
    var expecteddstqty = 1 / (1 - fee) * K / (srctotalqty - srcqty);
    if (abs(expecteddstqty - dstqty) > epsilon) then fail(("INVALID_DST_QTY",expecteddstqty));
    token.update(src, { totalqty -= srcqty });
    token.update(dst, { totalqty += dstqty });
    if src = "XTZ"  then begin
      var xtzin : nat = transferred;
      if srcqty <> xtzin then fail(("INVALID_SRC_QTY",xtzin))
    end else
      match_option entrypoint<(address * address * nat)>("%transfer",token[src].addr) with
      | some(transfer_src) ->
        transfer 0tz to entry transfer_src((caller, selfaddress, srcqty))
      | none -> fail("INVALID_SRC_ENTRY")
      end;
    if dst = "XTZ" then
      transfer (dstqty * 1tz) to caller
    else
      match_option entrypoint<(address * address * nat)>("%transfer",token[dst].addr) with
      | some(transfer_dst) ->
        transfer 0tz to entry transfer_dst((selfaddress, caller, dstqty))
      | none -> fail("INVALID_DST_ENTRY")
      end;
  }
}

/*
  'caller' sends XTZ and 'destqty' of 'dst' tokens so that
  the value of transferred (just approved so far) dst tokens is equal
  to the value of transferred XTZ.

  LQT tokens are minted so that it reflects the proportion of the transferred
  value towards the pool.

  Let 'mintedltq' be the number of minted LTQ tokens.
  mintedLTQ / token[dst].totalltq = transferred XTZ / token[dts].pool <=>
  mintedLTQ = token[dst].totalltq * transferred XTZ / token[dts].pool
*/
entry addLiquidity(dst : string, dstqty : nat) {
  /* TODO : check transferred value */
  match_option entrypoint<(address * address * nat)>("%transfer",token[dst].addr) with
   | some(transfer_src) ->
     transfer 0tz to entry transfer_src((caller, selfaddress, dstqty))
   | none -> fail("INVALID_DST_ENTRY")
  end;
  /* mint LTQ tokens */
  var xtzin : nat = transferred;
  var mintedLTQ =
    if token[dst].poolvalue = 0 then initialminted
    else abs(floor(token[dst].totallqt * xtzin / token[dst].poolvalue));
  liquidity.addupdate((dst, caller), { lqt += mintedLTQ });
  token.update(dst, { poolvalue += xtzin; totalqty += dstqty; totallqt += mintedLTQ })
}

/*
  'caller' redeems its LTQ tokens; 2 transactions are generated :
  - transfer of XTZ in proportion of the token pool
  - transfer of src tokens in proportion of the token pool
*/
entry removeLiquidity(lqtqty : nat, dst : string) {
  require {
    r1 otherwise "NOT_ENOUGHT_LQT": lqtqty <= liquidity[(dst, caller)].lqt
  }
  effect {
    var lqtratio = lqtqty / token[dst].totallqt;
    transfer (lqtratio * token[dst].poolvalue * 1tz) to caller;
    match_option entrypoint<(address * address * nat)>("%transfer",token[dst].addr) with
    | some(transfer_src) ->
      var qty = abs(floor(lqtratio * token[dst].totalqty));
      transfer 0tz to entry transfer_src((selfaddress, caller, qty))
    | none -> fail("INVALID_DST_ENTRY")
   end;
  }

}
